## 1.2 概述

### 1.2.1 范围

ASM 库的目的是生成、转换和分析以字节数组表示的已编译 Java 类（它们在磁盘中的存储和在 Java 虚拟机中的加载都采用这种字节数组形式）。为此，ASM 提供了一些工具，使用高于字节级别的概念来读写和转换这种字节数组，这些概念包括数值常数、字符串、Java 标识符、Java 类型、Java 类结构元素，等等。注意，ASM 库的范围严格限制于类的读、写、转换和分析。具体来说，类的加载过程就超出了它的范围之外。

### 1.2.2 模型

ASM 库提供了两个用于生成和转换已编译类的 API，一个是核心 API，以基于事件的形式来表示类，另一个是树 API，以基于对象的形式来表示类。

在采用基于事件的模型时，类是用一系列事件来表示的，每个事件表示类的一个元素，比如它的一个标头、一个字段、一个方法声明、一条指令，等等。基于事件的 API 定义了一组可能事件，以及这些事件必须遵循的发生顺序，还提供了一个类分析器，为每个被分析元素生成一个事件，还提供一个类写入器，由这些事件的序列生成经过编译的类。

而在采用基于对象的模型时，类用一个对象树表示，每个对象表示类的一部分，比如类本身、一个字段、一个方法、一条指令，等等，每个对象都有一些引用，指向表示其组成部分的对象。基于对象的 API 提供了一种方法，可以将表示一个类的事件序列转换为表示同一个类的对象树， 也可以反过来，将对象树表示为等价的事件序列。换言之，基于对象的 API 构建在基于事件的 API 之上。

这两个 API 可以与“用于 XML 的简单 API”（Simple API for XML，SAX）和用于 XML 文档的“文档对象模型（Document Object Model，DOM）API”相比较：基于事件的 API 类似于 SAX，而基于对象的 API 类似于 DOM。基于对象的 API 构建在基于事件的 API 之上，类似于 DOM 可在 SAX 的上层提供。

ASM 之所以要提供两个 API，是因为没有哪种 API 是最佳的。实际上，每个 API 都有自己的优缺点：

基于事件的 API 要快于基于对象的 API，所需要的内存也较少，因为它不需要在内存中创建和存储用于表示类的对象树（SAX 与 DOM 之间也有同样的差异）。
但在使用基于事件的 API 时，类转换的实现可能要更难一些，因为在任意给定时刻， 类中只有一个元素可供使用（也就是与当前事件对应的元素），而在使用基于对象的 API 时，可以在内存中获得整个类。 注意，这两个 API 都是仅能同时维护一个类，而且独立于其他类，也就是说，它们不会维护有关类层级结构的信息，如果类的转换影响到其他类，那其他这些类的修改应当由用户负责完成。

注意，这两个 API 都是仅能同时维护一个类，而且独立于其他类，也就是说，它们不会维护有关类层级结构的信息，如果类的转换影响到其他类，那其他这些类的修改应当由用户负责完成。

### 1.2.3 体系结构

ASM  应用程序拥有一个很强壮的体系结构方面（aspect）。事实上，对于基于事件的 API，其组织结构是围绕事件生成器（类分析器）、事件使用器（类写入器）和各种预定义的事件筛选器进行的，在这一结构中可以添加用户定义的生成器、使用器和筛选器。因此，这一 API 的使用分为两个步骤：

将事件生成器、筛选器和使用器组件组装为可能很复杂的体系结构，
然后启动事件生成器，以执行生成或转换过程。

基于对象的 API 也有一个体系结构方面：实际上，用于操作类树的类生成器或转换器组件是可以组成形成的，它们之间的链接代表着转换的顺序。

尽管典型 ASM 应用程序中的大多数组件体系结构都非常简单，但还是可以想象一下类似于如下所示的复杂体系结构，其中的箭头表示在类分析器、写入器或转换器之间进行的基于事件或基于对象的通信，在整个链中的任何位置，都可能会在基于事件与基于对象的表示之间进行转换：

![](http://asm.itstack.org/assets/img/2020/1.2.3.png)